# 版本控制之道——使用 Git
## 第三章 创建第一个项目
### 3.5 处理发布
#### 给指定分支添加 tag

``` bash
$ git tag <tagName> <branchName>
```

这样会在分支 branchName 的末梢打上 tagName 的 tag

#### 变基命令
See Also [9.3 分支变基](#93-分支变基)

#### 给 tag 打补丁
See Also [8.1 使用标签标记里程碑](#81-使用标签标记里程碑)

#### 为代码发布创建归档文件
See Also [9.2 导出版本库](#92-导出版本库)

## 第四章 添加与提交：Git 基础
### 4.1 添加文件到暂存区
命令 `git add -p` 能够在不进入交互模式的情况下直接进入补丁模式。

补丁模式是 Git 中非常有用的模式，在补丁模式中 Git 会显示这些文件的当前内容与版本库的差异，然后可以据此决定是否添加这些修改到暂存区。

### 4.2 提交修改
命令 `git commit -a` 会把已经纳入 Git 版本控制的文件提交，而不会添加尚未被跟踪的文件。

### 4.3 查看修改内容
`git diff` 默认会比较工作目录树和暂存区的区别，因此如果已经把文件加入了暂存区，那么 `git diff` 命令是无法看到任何 diff 信息的。这时可以使用 `git diff --cached` 命令来比较暂存区和版本库之间的区别。

### 4.4 管理文件
#### 文件的重命名与移动
命令 `git mv <old name> <new name>` 打包了 `mv <old name> <new name>` 、 `git add <new name>` 和 `git rm <old name>`  三个操作。

## 第五章 理解和使用分支
### 5.3 合并分支间的修改
#### 直接合并 (straight merge)

```bash
$ git merge <branchName>
```

#### 压合合并 (squashed commits)
压合指的是 Git 将一条分支上的所有历史提交压合成一个提交，提交到另一条分支上。_要小心使用压合提交_，因为大多数情况下，每个提交都应该作为一个单独的条目存在于历史记录中。

如果某条分支上的所有提交都密切相关，应随后作为一个正题记录（在父分支上）时，适合作压合提交。

```bash
$ git merge --squash <branchName>
```

这条命令会将 branchName 分支上的全部提交压合成当前分支上的一个提交，但这个时候，这些改变还没有提交，需要再次输入 `git commit` 命令进行提交。

#### 拣选合并 (cherry-picking)

```bash
$ git cherry-pick <commit SHA-1>
```

中间跳过了几个 commit ，可能会要求处理冲突。可以带上 -n 参数，用于拣选多个提交，进行合并操作，等全部拣选完毕后输入 `git commit` 命令提交。

### 5.4 冲突处理
一旦发生冲突后，就会在发生冲突的文件里发现 `<<<<<<< <branchName1>:<fileName>`，`=======` 和 `>>>>>>> <branchName2>:<fileName>` 这样的标识。

`<<<<<<<` 后面跟随的是当前分支 branchName1 中的代码。而 `>>>>>>>` 之前则是另一条分支 branchName2 上的代码。

可以使用 `git mergetool` 工具来解决复杂的冲突，不同的系统不同的环境会有不同的工具，Git 会尽可能的找到每一个合并工具。

所有合并工具得到的结果应该都差不多，都是显示各冲突区域，供用户选取定夺。

解决了所有冲突后，Git 自动暂存修改，等待提交。

### 5.6 分支重命名
命令 `git branch -m <old name> <new name>` 可以用来重命名分支。

## 第六章 查询 Git 历史记录
### 6.2 指定查找范围
在 `git log` 后面可以跟上以下参数用于指定查找范围：

* `--since` 最近的时间内的提交
* `--before` 多少时间前的最后一个提交
* `<commit1 SHA-1>..<commit2 SHA-1>` 检索从 commit1 到 commit2 之间的提交（不包括 commit1）

`-since` 和 `--before` 参数接受大多数英文格式的日期。Git 工具本身能够识别诸如 "24 hours"、"1 minute"、"2008-10.01" 这样格式的日期，哪怕日期中间既有连字符又有句点。

第三种检索方式可以省略 `<commit2 SHA-1>` ，这时 commit2 就会被 HEAD 替代，也可以用 tag 名替代。

另一种指定版本的常见方法是指出它与另一版本的关系，此时有两种操作符可以使用：

* ^ 相当于回溯一个版本。`2222222^` 相当于 2222222 的前一个版本； `2222222^^` 代表 2222222 的前第二个版本（也可以写作 `2222222^2`，`^` 其实是 `^1` 的别名）
* ~N 回溯 N 个版本。 `2222222^` 相当于 `222222~1`

可以混合使用两种操作符。

### 6.3 查看版本之间的差异
在 `git diff` 中指定版本范围和 `git log` 一样，唯一差别是 `git diff` 输出的是最老版本和最新版本之间的差异。

在 `git diff` 中使用标签作为参数，是一种获取发布版本之间代码量统计的好方法，通过加入一个 `--stat` 参数，可以计算出修改和删除的代码行数。如果只传入一个参数，Git 会默认把工作目录树作为参数。

### 6.4 查明该向谁问责
命令 `git blame` 用于查看特定代码块的历史信息。通过传入 `-L` 参数可以缩小显示的范围，范围用 `<start>,<end>` 表示。范围的值可以是数字，可以是 +N,-N 的形式，也可以是正则表达式。同时，`blame` 命令也可以使用 [指定查找范围](#62-指定查找范围) 中的操作符：

```bash
$ git blame -L "/<\/body>/",-2 2222222^ -- hello.html
```

命令中的 `--` 符号是在通知 Git 查询指定文件。

### 6.5 跟踪内容
命令 `git blame` 加入参数 `-M` 可以检测同一个文件内移动或复制的代码行，用同一个提交名称标识。加入参数 `-C -C` 可以检测文件之间的复制：

```bash
$ git blame -C -C cp.txt
```

Git 会输出初始的提交名称和初始的文件名。给 `git log` 传入参数 `-C -C` 也能显示复制信息，如果传入 `-p` 参数，`git log` 还会显示代码的具体变动。

### 6.6 撤销修改
#### 增补提交
在 `git commit` 命令中传入 `-C <commit SHA-1>` 参数，Git 会复用那个提交的 commit，如果传入的是小写的 c ，就会打开预设的编辑器，以便在已有的提交留言基础上编辑修改。

增补提交只能针对最后一个提交，如果想更正几个提交之前的某个错误，就需要用到 `git revert` 命令。

#### 反转提交
命令 `git revert <commit SHA-1>` 通过在版本库中创建一个“反向的”新提交来抵消原来提交的改动。在命令中加入 `-n` 参数可以制止 Git 立即提交反转结果，来进行多次反转。

通常，命令会启动默认编辑器并把默认信息加入其中，可以添加参数 `--no-edit` 直接使用默认的 commit 信息。

#### 复位
命令 `git reset <commit SHA-1>` 的默认参数是 HEAD ，可以使用 [指定查找范围](#62-指定查找范围) 中的操作符。如果传入 `--soft` 参数，Git 会暂存所有因果复位带来的差异，但不提交。用户可以修改这些内容再提交。

如果传入 `--hard` 参数，Git 会从版本库和工作目录同时删除提交，不可恢复。

### 6.7 重新改写历史记录
命令 `git rebase -i` 能够以人机交互的方式改写历史记录。具体内容可以看 《Pro Git》 的 第六章第四节 [《重写历史》](http://github.danmarner.com/section/ch6-4/) 和 《Git 魔法》的第五章 [《关于历史》](http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/ch05.html) 。

## 第七章 与远程版本库合作
### 7.5 添加新的远程版本库
在本地版本库中，远程版本库的别名默认是 origin 。它是克隆远程版本库时自动生成的。

命令 `git remote add <别名> <版本库全称>` 用于为远程版本库添加别名。

命令 `git remote rm` 用于删除别名。

## 第八章 管理本地版本库
### 8.1 使用标签标记里程碑

```bash
$ git checkout <tagName>
```

这时会检出直到 <tagName> 的历史到 `(no branch)` 上。

```bash
$ git [branch|checkout -b] <branchName> <tagName>
```

这时就会检出到 tagName 为止的代码到 branchName 分支

## 第九章 高阶功能
### 9.1 压缩版本库
Git 版本库里存储了*所有的东西*，由此带来的问题是偶尔会留下一些没有用的数据。比如 `--amend` 时 Git 也会记住原来的版本；或者用 `git branch -D` 删除一个试验分支时，Git 依旧会保留该分支上的内容。

命令 `git gc` 整理版本库以优化 Git 内部存储历史记录，一个月清理一次，或者大约100次提交清理一次即可。它不改变历史记录，只改变历史记录的存储方式。

在命令中带上 `--aggressive` 参数可使版本库得到进一步的优化。这会增加时间，但值得尝试。

Git 在增量存储单元 (delta) 中存储修改。一般情况下， `git gc` 命令运行时会压缩这些增量存储单元，但是不会重新计算它们。如果使用 `--aggressive` 参数，则 Git 会重新计算它们。

### 9.2 导出版本库

```bash
$ git archive --format tar \
              --prefix=mysite-1.0/ 1.0 \
              | gzip > mysite-10.tar.gz
```

`--format` 指明要产生 tar 格式的输出；`--prefix` 指明包中所有东西都放到 mysite-1.0/ 目录下；`1.0` 指明需要归档的标签名称。

也可以用

```bash
$ git archive --format zip \
              --prefix=mysite-1.0/ 1.0 \
              > mysite-10.zip
```

来产生一个 zip 文件。

### 9.3 分支变基
要同步分支之间的历史，除了使用 Git 提供的合并分支功能，还可以使用变基操作。

```bash
$ git rebase <branchName>
```

变基的意思是“改变分支的基底”，把一条分支上的修改在另一条分支的末梢重现。你可以把这种方式看作是基于一个新的基点，重演分支上发生过的改动。
