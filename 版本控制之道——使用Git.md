# 版本控制之道——使用 Git
## 第三章 创建第一个项目
### 3.5 处理发布
#### 给指定分支添加 tag

``` bash
$ git tag <tagName> <branchName>
```

这样会在分支 branchName 的末梢打上 tagName 的 tag

#### 变基命令

```bash
$ git rebase <branchName>
```

变基的意思是“改变分支的基底”，把一条分支上的修改在另一条分支的末梢重现。与此同时，rebase 还有重写历史的用途。

#### 给 tag 打补丁

```bash
$ git [branch|checkout -b] <branchName> <tagName>
```

这时就会检出到 tagName 为止的代码到 branchName 分支

#### 为代码发布创建归档文件

```bash
$ git archive --format tar \
              --prefix=mysite-1.0/ 1.0 \
              | gzip > mysite-10.tar.gz
```

`--format` 指明要产生 tar 格式的输出；`--prefix` 指明包中所有东西都放到 mysite-1.0/ 目录下；`1.0` 指明需要归档的标签名称。

也可以用

```bash
$ git archive --format zip \
              --prefix=mysite-1.0/ 1.0 \
              > mysite-10.zip
```

来产生一个 zip 文件。

## 第四章 添加与提交：Git 基础
### 4.1 添加文件到暂存区
命令 `git add -p` 能够在不进入交互模式的情况下直接进入补丁模式。

补丁模式是 Git 中非常有用的模式，在补丁模式中 Git 会显示这些文件的当前内容与版本库的差异，然后可以据此决定是否添加这些修改到暂存区。

### 4.2 提交修改
命令 `git commit -a` 会把已经纳入 Git 版本控制的文件提交，而不会添加尚未被跟踪的文件。

### 4.3 查看修改内容
`git diff` 默认会比较工作目录树和暂存区的区别，因此如果已经把文件加入了暂存区，那么 `git diff` 命令是无法看到任何 diff 信息的。这时可以使用 `git diff --cached` 命令来比较暂存区和版本库之间的区别。

### 4.4 管理文件
#### 文件的重命名与移动
命令 `git mv <old name> <new name>` 打包了 `mv <old name> <new name>` 、 `git add <new name>` 和 `git rm <old name>`  三个操作。

## 第五章 理解和使用分支
### 5.3 合并分支间的修改
#### 直接合并 (straight merge)

```bash
$ git merge <branchName>
```

#### 压合合并 (squashed commits)
压合指的是 Git 将一条分支上的所有历史提交压合成一个提交，提交到另一条分支上。_要小心使用压合提交_，因为大多数情况下，每个提交都应该作为一个单独的条目存在于历史记录中。

如果某条分支上的所有提交都密切相关，应随后作为一个正题记录（在父分支上）时，适合作压合提交。

```bash
$ git merge --squash <branchName>
```

这条命令会将 branchName 分支上的全部提交压合成当前分支上的一个提交，但这个时候，这些改变还没有提交，需要再次输入 `git commit` 命令进行提交。

#### 拣选合并 (cherry-picking)

```bash
$ git cherry-pick <commit SHA-1>
```

中间跳过了几个 commit ，可能会要求处理冲突。可以带上 -n 参数，用于拣选多个提交，进行合并操作，等全部拣选完毕后输入 `git commit` 命令提交。

### 5.6 分支重命名
命令 `git branch -m <old name> <new name>` 可以用来重命名分支。

## 第六章 查询 Git 历史记录
### 6.2 指定查找范围
在 `git log` 后面可以跟上以下参数用于指定查找范围：

* `--since` 最近的时间内的提交
* `--before` 多少时间前的最后一个提交
* `<commit1 SHA-1>..<commit2 SHA-1>` 检索从 commit1 到 commit2 之间的提交（不包括 commit1）

`-since` 和 `--before` 参数接受大多数英文格式的日期。Git 工具本身能够识别诸如 "24 hours"、"1 minute"、"2008-10.01" 这样格式的日期，哪怕日期中间既有连字符又有句点。

第三种检索方式可以省略 `<commit2 SHA-1>` ，这时 commit2 就会被 HEAD 替代，也可以用 tag 名替代。

另一种指定版本的常见方法是指出它与另一版本的关系，此时有两种操作符可以使用：

* ^ 相当于回溯一个版本。`2222222^` 相当于 2222222 的前一个版本； `2222222^^` 代表 2222222 的前第二个版本（也可以写作 `2222222^2`，`^` 其实是 `^1` 的别名）
* ~N 回溯 N 个版本。 `2222222^` 相当于 `222222~1`

可以混合使用两种操作符。

### 6.3 查看版本之间的差异
在 `git diff` 中指定版本范围和 `git log` 一样，唯一差别是 `git diff` 输出的是最老版本和最新版本之间的差异。

在 `git diff` 中使用标签作为参数，是一种获取发布版本之间代码量统计的好方法，通过加入一个 `--stat` 参数，可以计算出修改和删除的代码行数。如果只传入一个参数，Git 会默认把工作目录树作为参数。

### 6.4 查明该向谁问责
命令 `git blame` 用于查看特定代码块的历史信息。通过传入 `-L` 参数可以缩小显示的范围，范围用 `<start>,<end>` 表示。范围的值可以是数字，可以是 +N,-N 的形式，也可以是正则表达式。同时，`blame` 命令也可以使用 [指定查找范围] 中的操作符：

```bash
$ git blame -L "/<\/body>/",-2 2222222^ -- hello.html
```

命令中的 `--` 符号是在通知 Git 查询指定文件。

### 6.5 跟踪内容
命令 `git blame` 加入参数 `-M` 可以检测同一个文件内移动或复制的代码行，用同一个提交名称标识。加入参数 `-C -C` 可以检测文件之间的复制：

```bash
$ git blame -C -C cp.txt
```

Git 会输出初始的提交名称和初始的文件名。给 `git log` 传入参数 `-C -C` 也能显示复制信息，如果传入 `-p` 参数，`git log` 还会显示代码的具体变动。

### 6.6 撤销修改
#### 增补提交
在 `git commit` 命令中传入 `-C <commit SHA-1>` 参数，Git 会复用那个提交的 commit，如果传入的是小写的 c ，就会打开预设的编辑器，以便在已有的提交留言基础上编辑修改。

增补提交只能针对最后一个提交，如果想更正几个提交之前的某个错误，就需要用到 `git revert` 命令。

#### 反转提交
命令 `git revert <commit SHA-1>` 通过在版本库中创建一个“反向的”新提交来抵消原来提交的改动。在命令中加入 `-n` 参数可以制止 Git 立即提交反转结果，来进行多次反转。

通常，命令会启动默认编辑器并把默认信息加入其中，可以添加参数 `--no-edit` 直接使用默认的 commit 信息。

#### 复位
命令 `git reset <commit SHA-1>` 的默认参数是 HEAD ，可以使用 [指定查找范围] 中的操作符。如果传入 `--soft` 参数，Git 会暂存所有因果复位带来的差异，但不提交。用户可以修改这些内容再提交。

如果传入 `--hard` 参数，Git 会从版本库和工作目录同时删除提交，不可恢复。

### 6.7 重新改写历史记录
命令 `git rebase -i` 能够以人机交互的方式改写历史记录。具体内容可以看 《Pro Git》 的 第六章第四节 [《重写历史》](http://github.danmarner.com/section/ch6-4/) 和 《Git 魔法》的第五章 [《关于历史》](http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/ch05.html) 。

## 第七章 与远程版本库合作
### 7.5 添加新的远程版本库
在本地版本库中，远程版本库的别名默认是 origin 。它是克隆远程版本库时自动生成的。

命令 `git remote add <别名> <版本库全称>` 用于为远程版本库添加别名。

命令 `git remote rm` 用于删除别名。

## 第八章 管理本地版本库
### 8.1 使用标签标记里程碑

```bash
$ git checkout <tagName>
```

See also [3.5 处理发布 > 给 tag 打补丁]

### 8.2 发布分支的处理
发布分支是指即将要发布代码的地方，开发团队一半用它来隔离即将要发布的代码。*隔离*(segregate)的具体含义要视具体情况而定。

在这里可以试着了解一下 git flow 这个 git 的外挂与其附带的分支模型 [a success branch model]。

### 8.3 标签与分支的有效名称

* 不能以反斜杠作为标签或分支的结尾，这样做是为了让用户可以像组织文件一样组织标签和分支
* 不能将圆点置于各段名称的开头，具体原因和上面一条相同，因为 *nix 把以圆点开头的文件或目录看作是隐藏项
* 不能在标签或分支的名称中使用特殊字符，包括空格、波浪号 “~”、脱字符 “^”、冒号 “:”、问号 “?”、星号 “*”、方括号 “[”等
* 不能在标签或分支名中使用所有编码小于 “\040” 的 ASCII 控制字符和删除键（ ASCII 码 “\177” ） [1]
* 不能在名称的任何地方出现双圆点 “..” ，具体参见 [6.2 指定查找范围](#6.2 指定查找范围)

### 8.4 记录和跟踪多个项目
在 Git 中有多种方法来管理多个项目。接下来各呈利弊。

#### 多个项目共享一个版本库
当处理的项目需要统一的历史记录时，这种办法很适用。例如一个由多个组建构成的项目，且这些项目总是同时发布。

请注意，这里强调“同时发布”。当决定一个版本库是包括一个项目还是多个项目时，这是最关键的因素。

使用同一个版本库共享历史可以确保版本库中所有的历史记录都围绕着一个大项目。

#### 多个项目多个版本库
决定什么情况下应该将项目分隔开来并不难：如果各小项目是单独发布的。它们就应该有自己独立的版本库。

但是规则并不是一成不变的，如果两个项目要单独发布，但是它们之间的关系紧密，不能单独使用，那么可把它们放在同一个版本库中会更为方便。

### 8.5 使用 Git 子模块跟踪外部版本库
列出子模块：

```bash
$ git submodule
```

Git 子模块跟踪了远程版本库的一个特定版本，以一个哈希值来标明。

如果哈希值前有个减号，就表明子模块还没有初始化。

如果哈希值前面有个加号，标识它不是“容器”版本库所记录的该子模块所在的版本。

#### 添加新子模块

```bash
$ git submodule add <remote repo url> <submodule path>
```

#### 初始化子模块

```bash
$ git submodule init <submoduleName>
```

这时 `git status` 就会显示两个文件发生了改变，一个是 .gitmodules ，一个是 sumoduleName 。

Git 版本库记录和跟踪 .gitmodules 文件，当别人共享你的版本库时，Git 就可以根据这个文件中的信息来部署它们的子模块。

#### 从远程版本库抓取内容

```bash
$ git submodule update <submoduleName>
```

#### 改变子模块的版本
Git 子模块不会自动引用版本库中的最新提交：子模块只反映某个提交对应的版本。当初添加子模块的时候，Git 总是用源库当时的 HEAD。

可以通过 `git checkout` 命令切换到某个历史版本，然后 commit 子模块目录来改变版本库中的子模块的版本。

#### 使用子模块是要提防的错误
命令 `git submodule update` 是 “毁灭性” 的，它会覆盖本地子模块中所有没有提交的内容。

一旦子模块提交了修改，必须确保这些改动被送回子模块的远程版本库中。这样才能在本地“容器”版本库中改变引用的子模块版本。否则，当运行 `git submodule update` 的时候，Git 会因为在子模块的远程版本库找不到对应版本，而产生不可预测的后果。

## 第九章 高阶功能
### 9.1 压缩版本库
Git 版本库里存储了*所有的东西*，由此带来的问题是偶尔会留下一些没有用的数据。比如 `--amend` 时 Git 也会记住原来的版本；或者用 `git branch -D` 删除一个试验分支时，Git 依旧会保留该分支上的内容。

命令 `git gc` 整理版本库以优化 Git 内部存储历史记录，一个月清理一次，或者大约100次提交清理一次即可。它不改变历史记录，只改变历史记录的存储方式。

在命令中带上 `--aggressive` 参数可使版本库得到进一步的优化。这会增加时间，但值得尝试。

Git 在增量存储单元 (delta) 中存储修改。一般情况下， `git gc` 命令运行时会压缩这些增量存储单元，但是不会重新计算它们。如果使用 `--aggressive` 参数，则 Git 会重新计算它们。

## 9.2 导出版本库
